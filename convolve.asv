function out_img = convolve(img, kernel, ksize)
% 需要把图像数据转换为 double 进行运算
img = im2double(img);

% 填充图像边界
pad_size = floor(ksize / 2);
padded_img = padarray(img, [pad_size, pad_size], 'symmetric', 'both');

% 卷积
out_img = zeros(size(img));
for i = 1:3 % 对每个颜色通道分别处理
    out_img(:, :, i) = conv2(padded_img(:, :, i), kernel);
end

% 在 [0, 1] 内裁剪通道，确保不超出 RGB 色域
out_img(out_img < 0) = 0;
out_img(out_img > 1) = 1;
end

function C = conv2(A, B)
    % Get the sizes of the input matrices
    [mA, nA] = size(A);
    [mB, nB] = size(B);

    % Determine the size of the output matrix
    mC = mA + mB - 1;
    nC = nA + nB - 1;
    
    % Initialize the output matrix with zeros
    C = zeros(mC, nC);
    
    % Flip the kernel for convolution
    B = rot90(B, 2);
    
    % Pad the input matrix with zeros
    Apad = padarray(A, [mB - 1, nB - 1], 'both');
    
    % Perform the convolution using matrix multiplication
    for i = 1:mC
        for j = 1:nC
            % Extract the submatrix
            subA = Apad(i:i+mB-1, j:j+nB-1);
            % Perform element-wise multiplication and sum the result
            C(i, j) = sum(subA .* B, 'all');
        end
    end
end
